# ================================

# 1. MODEL - app/models/user.py

# ================================

from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class UserModel(Base):
"""Modelo SQLAlchemy para a tabela de usuários"""
**tablename** = "users"

    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    name = Column(String, nullable=False)
    email = Column(String, nullable=False, unique=True, index=True)
    password = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self):
        return f"<User(id={self.id}, email={self.email}, name={self.name})>"

# ================================

# 2. SCHEMAS - app/schemas/user.py

# ================================

from datetime import datetime
from pydantic import BaseModel, EmailStr, Field
from typing import Optional

class UserCreateSchema(BaseModel):
"""Schema para criar usuário - dados de entrada"""
name: str = Field(..., min_length=2, max_length=100, description="Nome do usuário")
email: EmailStr = Field(..., description="Email único do usuário")
password: str = Field(..., min_length=6, max_length=50, description="Senha do usuário")

    class Config:
        json_schema_extra = {
            "example": {
                "name": "João Silva",
                "email": "joao.silva@email.com",
                "password": "123456"
            }
        }

class UserResponseSchema(BaseModel):
"""Schema para resposta - dados de saída (sem senha)"""
id: int
name: str
email: str
created_at: datetime
updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True  # Para compatibilidade com SQLAlchemy models
        json_schema_extra = {
            "example": {
                "id": 1,
                "name": "João Silva",
                "email": "joao.silva@email.com",
                "created_at": "2025-08-22T10:30:00",
                "updated_at": "2025-08-22T10:30:00"
            }
        }

# ================================

# 3. FACTORY - app/factories/user_factory.py

# ================================

from app.schemas.user import UserCreateSchema, UserResponseSchema
from app.models.user import UserModel
from typing import Dict

class UserFactory:
"""Factory para criar instâncias de User de forma padronizada"""

    @staticmethod
    def create_user_dict_from_schema(user_data: UserCreateSchema) -> Dict:
        """
        Converte UserCreateSchema para dicionário padronizado

        Args:
            user_data: Dados do usuário vindos do schema

        Returns:
            dict: Dicionário com dados limpos e padronizados
        """
        return {
            "name": user_data.name.strip().title(),  # Remove espaços e padroniza
            "email": user_data.email.lower().strip(),  # Email sempre minúsculo
            "password": user_data.password  # Senha como veio (sem criptografia no escopo)
        }

    @staticmethod
    def create_response_from_model(user_model: UserModel) -> UserResponseSchema:
        """
        Converte UserModel para UserResponseSchema

        Args:
            user_model: Instância do modelo SQLAlchemy

        Returns:
            UserResponseSchema: Schema de resposta sem dados sensíveis
        """
        return UserResponseSchema(
            id=user_model.id,
            name=user_model.name,
            email=user_model.email,
            created_at=user_model.created_at,
            updated_at=user_model.updated_at
        )

# ================================

# 4. REPOSITORY - app/repositories/user_repository.py

# ================================

from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from typing import List, Optional, Dict
from app.models.user import UserModel

class UserRepository:
"""Repository para operações de dados do usuário"""

    def __init__(self, db_session: Session):
        """
        Inicializa repository com sessão do banco

        Args:
            db_session: Sessão SQLAlchemy para operações de BD
        """
        self.db = db_session

    def create(self, user_data: Dict) -> UserModel:
        """
        Cria novo usuário no banco de dados

        Args:
            user_data: Dicionário com dados do usuário

        Returns:
            UserModel: Usuário criado

        Raises:
            IntegrityError: Se email já existir
        """
        try:
            user = UserModel(**user_data)
            self.db.add(user)
            self.db.commit()
            self.db.refresh(user)
            return user
        except IntegrityError as e:
            self.db.rollback()
            raise e

    def get_all(self) -> List[UserModel]:
        """
        Busca todos os usuários

        Returns:
            List[UserModel]: Lista de todos os usuários
        """
        return self.db.query(UserModel).all()

    def get_by_email(self, email: str) -> Optional[UserModel]:
        """
        Busca usuário por email

        Args:
            email: Email do usuário

        Returns:
            Optional[UserModel]: Usuário encontrado ou None
        """
        return self.db.query(UserModel).filter(UserModel.email == email).first()

    def exists_by_email(self, email: str) -> bool:
        """
        Verifica se usuário existe por email

        Args:
            email: Email do usuário

        Returns:
            bool: True se existir, False caso contrário
        """
        return self.db.query(UserModel).filter(UserModel.email == email).first() is not None

# ================================

# 5. SERVICE - app/services/user_service.py

# ================================

from app.repositories.user_repository import UserRepository
from app.schemas.user import UserCreateSchema, UserResponseSchema
from app.factories.user_factory import UserFactory
from app.core.exceptions import UserAlreadyExistsError, DatabaseError
from typing import List
import logging

logger = logging.getLogger(**name**)

class UserService:
"""Service para lógica de negócio relacionada a usuários"""

    def __init__(self, user_repository: UserRepository):
        """
        Inicializa service com repository

        Args:
            user_repository: Repository para operações de dados
        """
        self.user_repository = user_repository

    def create_user(self, user_data: UserCreateSchema) -> UserResponseSchema:
        """
        Cria novo usuário com validações de negócio

        Args:
            user_data: Dados do usuário para criação

        Returns:
            UserResponseSchema: Usuário criado

        Raises:
            UserAlreadyExistsError: Se email já existir
            DatabaseError: Se houver erro no banco de dados
        """
        try:
            logger.info(f"Tentando criar usuário com email: {user_data.email}")

            # Validar se email já existe
            if self.user_repository.exists_by_email(user_data.email):
                logger.warning(f"Tentativa de criar usuário com email já existente: {user_data.email}")
                raise UserAlreadyExistsError(user_data.email)

            # Converter schema para dict via factory
            user_dict = UserFactory.create_user_dict_from_schema(user_data)

            # Criar usuário no banco
            user_model = self.user_repository.create(user_dict)

            # Converter model para response schema via factory
            response = UserFactory.create_response_from_model(user_model)

            logger.info(f"Usuário criado com sucesso: ID {user_model.id}")
            return response

        except UserAlreadyExistsError:
            raise  # Re-propaga erro de negócio
        except Exception as e:
            logger.error(f"Erro ao criar usuário: {str(e)}")
            raise DatabaseError(f"Erro interno ao criar usuário: {str(e)}")

    def get_all_users(self) -> List[UserResponseSchema]:
        """
        Busca todos os usuários

        Returns:
            List[UserResponseSchema]: Lista de usuários

        Raises:
            DatabaseError: Se houver erro no banco de dados
        """
        try:
            logger.info("Buscando todos os usuários")

            user_models = self.user_repository.get_all()

            # Converter models para response schemas via factory
            users_response = [
                UserFactory.create_response_from_model(user)
                for user in user_models
            ]

            logger.info(f"Encontrados {len(users_response)} usuários")
            return users_response

        except Exception as e:
            logger.error(f"Erro ao buscar usuários: {str(e)}")
            raise DatabaseError(f"Erro interno ao buscar usuários: {str(e)}")

# ================================

# 6. CONTROLLER - app/controllers/user_controller.py

# ================================

from fastapi import HTTPException, status
from app.services.user_service import UserService
from app.schemas.user import UserCreateSchema, UserResponseSchema
from app.core.exceptions import UserAlreadyExistsError, DatabaseError
from typing import List, Dict
import logging

logger = logging.getLogger(**name**)

class UserController:
"""Controller para manipular requests HTTP relacionados a usuários"""

    def __init__(self, user_service: UserService):
        """
        Inicializa controller com service

        Args:
            user_service: Service para lógica de negócio
        """
        self.user_service = user_service

    def create_user(self, user_data: UserCreateSchema) -> Dict:
        """
        Endpoint para criar usuário

        Args:
            user_data: Dados do usuário para criação

        Returns:
            Dict: Resposta padronizada com dados do usuário

        Raises:
            HTTPException: Para erros HTTP apropriados
        """
        try:
            logger.info(f"Controller: Recebida requisição para criar usuário")

            user_response = self.user_service.create_user(user_data)

            return {
                "status": "success",
                "message": "Usuário criado com sucesso",
                "data": user_response.dict()
            }

        except UserAlreadyExistsError as e:
            logger.warning(f"Controller: Email já existe - {str(e)}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Email já cadastrado: {e.email}"
            )
        except DatabaseError as e:
            logger.error(f"Controller: Erro de banco - {str(e)}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Erro interno do servidor"
            )
        except Exception as e:
            logger.error(f"Controller: Erro inesperado - {str(e)}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Erro interno do servidor"
            )

    def list_users(self) -> Dict:
        """
        Endpoint para listar usuários

        Returns:
            Dict: Resposta padronizada com lista de usuários

        Raises:
            HTTPException: Para erros HTTP apropriados
        """
        try:
            logger.info("Controller: Recebida requisição para listar usuários")

            users_response = self.user_service.get_all_users()

            return {
                "status": "success",
                "message": f"Encontrados {len(users_response)} usuários",
                "data": [user.dict() for user in users_response]
            }

        except DatabaseError as e:
            logger.error(f"Controller: Erro de banco - {str(e)}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Erro interno do servidor"
            )
        except Exception as e:
            logger.error(f"Controller: Erro inesperado - {str(e)}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Erro interno do servidor"
            )

# ================================

# 7. ROUTER - app/routers/user_router.py

# ================================

from fastapi import APIRouter, Depends, status
from sqlalchemy.orm import Session
from typing import Dict
from app.controllers.user_controller import UserController
from app.services.user_service import UserService
from app.repositories.user_repository import UserRepository
from app.schemas.user import UserCreateSchema, UserResponseSchema
from app.database.connection import get_db

# Criar router

router = APIRouter(
prefix="/users",
tags=["users"]
)

def get_user_controller(db: Session = Depends(get_db)) -> UserController:
"""
Dependency injection para criar controller com dependências

    Args:
        db: Sessão do banco de dados

    Returns:
        UserController: Controller configurado
    """
    user_repository = UserRepository(db)
    user_service = UserService(user_repository)
    return UserController(user_service)

@router.post(
"/",
response_model=Dict,
status_code=status.HTTP_201_CREATED,
summary="Criar usuário",
description="Cria um novo usuário com validação de email único"
)
def create_user(
user_data: UserCreateSchema,
controller: UserController = Depends(get_user_controller)
) -> Dict:
"""
Cria um novo usuário

    - **name**: Nome do usuário (mínimo 2 caracteres)
    - **email**: Email único e válido
    - **password**: Senha (mínimo 6 caracteres)
    """
    return controller.create_user(user_data)

@router.get(
"/",
response_model=Dict,
status_code=status.HTTP_200_OK,
summary="Listar usuários",
description="Lista todos os usuários cadastrados (sem expor senhas)"
)
def list_users(
controller: UserController = Depends(get_user_controller)
) -> Dict:
"""
Lista todos os usuários

    Retorna todos os usuários cadastrados sem expor informações sensíveis
    como senhas.
    """
    return controller.list_users()

# ================================

# 8. EXCEPTIONS - app/core/exceptions.py

# ================================

class UserAlreadyExistsError(Exception):
"""Exceção para quando usuário já existe"""

    def __init__(self, email: str):
        self.email = email
        super().__init__(f"Usuário com email {email} já existe")

class UserValidationError(Exception):
"""Exceção para erros de validação de usuário"""
pass

class DatabaseError(Exception):
"""Exceção para erros relacionados ao banco de dados"""
pass

# ================================

# 9. DATABASE CONNECTION - app/database/connection.py

# ================================

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from app.core.config import settings
from app.models.user import Base

class DatabaseConnection:
"""Singleton para conexão com banco de dados"""
\_instance = None
\_engine = None
\_session_factory = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def get_engine(self):
        """Retorna engine do banco (singleton)"""
        if self._engine is None:
            self._engine = create_engine(
                settings.DATABASE_URL,
                connect_args={"check_same_thread": False}  # Para SQLite
            )
        return self._engine

    def get_session_factory(self):
        """Retorna factory de sessões"""
        if self._session_factory is None:
            engine = self.get_engine()
            self._session_factory = sessionmaker(
                autocommit=False,
                autoflush=False,
                bind=engine
            )
        return self._session_factory

    def create_tables(self):
        """Cria todas as tabelas"""
        engine = self.get_engine()
        Base.metadata.create_all(bind=engine)

# Instância singleton

db_connection = DatabaseConnection()

def get_db() -> Session:
"""
Dependency para obter sessão do banco de dados

    Yields:
        Session: Sessão do SQLAlchemy
    """
    session_factory = db_connection.get_session_factory()
    db = session_factory()
    try:
        yield db
    finally:
        db.close()

# ================================

# 10. CONFIG - app/core/config.py

# ================================

import os
from dotenv import load_dotenv

load_dotenv()

class Settings:
"""Configurações da aplicação"""
DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite:///./users.db")
API_HOST: str = os.getenv("API_HOST", "0.0.0.0")
API_PORT: int = int(os.getenv("API_PORT", "8000"))
DEBUG: bool = os.getenv("DEBUG", "True").lower() == "true"
SECRET_KEY: str = os.getenv("SECRET_KEY", "dev-secret-key")

settings = Settings()

# ================================

# 11. MAIN - app/main.py

# ================================

from fastapi import FastAPI
from app.routers.user_router import router as user_router
from app.database.connection import db_connection
import logging

# Configurar logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(**name**)

# Criar aplicação FastAPI

app = FastAPI(
title="Sistema de Registro de Usuários",
description="API para cadastro e listagem de usuários - Projeto POO",
version="1.0.0"
)

# Incluir routers

app.include_router(user_router)

@app.on_event("startup")
def startup_event():
"""Evento executado na inicialização da aplicação"""
logger.info("Iniciando aplicação...")

    # Criar tabelas no banco
    db_connection.create_tables()
    logger.info("Tabelas criadas/verificadas no banco de dados")

@app.get("/")
def read_root():
"""Endpoint raiz para verificar se API está funcionando"""
return {
"message": "API de Registro de Usuários",
"status": "online",
"docs": "/docs"
}

if **name** == "**main**":
import uvicorn
from app.core.config import settings

    uvicorn.run(
        "app.main:app",
        host=settings.API_HOST,
        port=settings.API_PORT,
        reload=settings.DEBUG
    )
