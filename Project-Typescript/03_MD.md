# 3 – Modelagem e Design (Concluído)

## Modelos de Dados

**Entidade Usuário**

-   `id: number` – identificador único
-   `nome: string` – nome do usuário
-   `email: string` – e-mail do usuário
-   `senha: string` – senha criptografada

**Relacionamentos**

-   Nenhum relacionamento complexo; foco apenas no registro de usuários

---

## Diagrama de Classes – Registro de Usuário

```
+-----------------+
|     Usuario     |
+-----------------+
| id: number      |
| nome: string    |
| email: string   |
| senha: string   |
+-----------------+
| +create()       |
| +update()       |
| +delete()       |
| +list()         |
+-----------------+
```

---

## Estrutura de Pastas – Camadas com Repository

```
project/
├── routes/           # Endpoints da API
│   └── userRoutes.ts
├── controllers/      # Recebem requests e chamam os serviços
│   └── userController.ts
├── services/         # Lógica de negócio e validações
│   └── userService.ts
├── repositories/     # Persistência em SQLite
│   └── userRepository.ts
├── models/           # Tipos e interfaces TypeScript
│   └── userModel.ts
├── dtos/             # DTOs para transporte e validação de dados
│   └── userDTO.ts
├── utils/            # Helpers, validações e tratamento de erros
├── app.ts            # Ponto de entrada do servidor
└── package.json
```

**Fluxo de dados com DTOs:**

```
Client → Routes → Controller → DTO → Service → Repository → SQLite
```

---

## Separação de Responsabilidades

-   **Routes:** definem endpoints da API
-   **Controllers:** recebem requests, chamam services e retornam respostas
-   **Services:** aplicam lógica de negócio, validações e regras CRUD
-   **Repositories:** realizam operações de persistência no banco
-   **Models:** definem estrutura de dados
-   **DTOs:** transportam dados entre camadas, aplicando validações
-   **Utils:** funções auxiliares, tratamento de erros, criptografia de senhas

---

## Padrões de Projeto

-   **Singleton:** instância única para conexão com SQLite
-   **Factory:** criação de DTOs ou objetos complexos de forma centralizada

---

## Princípios de Design Aplicados

-   **SOLID:**

    -   S: Responsabilidade única por classe
    -   D: Dependências injetadas via DTOs/interfaces

-   **DRY:** código reutilizável em utils e services
-   **KISS:** arquitetura simples e clara

---

## Uso de DTOs / Schemas

-   Implementação em TypeScript com interfaces ou classes
-   Validam tipos, obrigatoriedade de campos e regras de negócio simples
-   Evitam expor atributos sensíveis diretamente (ex.: senha)

**Exemplo DTO**

```ts
interface CreateUserDTO {
    nome: string
    email: string
    senha: string
}
```

---

## Estratégia de Tratamento de Erros

-   **Imperativa tradicional:** `try/catch`
-   **Funcional moderna:** `Result` ou `Either` para retorno explícito de sucesso/erro

**Exemplo combinado**

```ts
try {
    const result = userService.create(userDTO)
    if (result.isError) {
        return res.status(400).json({ message: result.error })
    }
    res.status(201).json(result.value)
} catch (err) {
    res.status(500).json({ message: "Erro interno do servidor" })
}
```

---

✅ **Modelagem e Design concluída:**

-   Modelos de dados definidos
-   Diagrama de classes simplificado
-   Estrutura de pastas organizada
-   Separação de responsabilidades clara
-   Padrões de projeto e princípios de design aplicados
-   Uso de DTOs para validação e transporte de dados
-   Estratégia de tratamento de erros definida
